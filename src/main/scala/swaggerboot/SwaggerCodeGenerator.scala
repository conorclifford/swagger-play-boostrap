package swaggerboot

import java.io.{File, PrintWriter}

import io.swagger.models.Swagger
import io.swagger.models.auth.OAuth2Definition
import io.swagger.parser.SwaggerParser
import org.apache.commons.io.FileUtils

import swaggerops._

object SwaggerCodeGenerator extends App {
  // FIXME better argument parsing would probably be a good idea at this stage.
  if (!(args.length == 2 || (args.length == 3 && args(2) == "-client") ||
       (args.length == 4 && Set(Set("-client", "-replace"), Set("-client", "-play23")).contains(Set(args(2), args(3)))) ||
       (args.length == 5 && Set(args(2), args(3), args(4)) == Set("-client", "-replace", "-play23")))) {
    System.err.println(
    """
      |Usage: SwaggerCodeGenerator <swagger-spec> <output-directory> [-client] [-overwrite]
      |    - <swagger-spec> - correctly formed Swagger API Specification - this tool has been only tested with YAML files.
      |    - <output-directory> must not exist (autocreated by this tool)
      |    - [-client] specifies that the client code should be generated (server code is generated by default)
      |    - [-replace] specifies to replace an existing source directory - note, this is currently ONLY AVAILABLE with -client.
      |    - [-play23] requests the generated code to be generated for play2.3  - note, this is currently ONLY AVAILABLE with -client, and is completely experimental.
    """.stripMargin)
    System.exit(1)
  }

  val swaggerSpec = args(0)
  val outputDir = new File(args(1))
  val genServerCode = args.length == 2
  val replace = !genServerCode && args.contains("-replace")
  val generatePlay23Code = !genServerCode && args.contains("-play23")

  if (!new File(swaggerSpec).isFile) {
    System.err.println(s"ERROR - swagger specification file '$swaggerSpec' is not a file...")
    System.exit(1)
  }

  if (!replace && outputDir.exists) {
    System.err.println(s"ERROR - output directory already exists, and not requested to be replaced")
    System.exit(1)
  }

  val swagger: Swagger = new SwaggerParser().read(swaggerSpec)

  private def logCyclicDefinitionWarning(defnName: String): Unit = {
    println(s"WARN - $defnName will be generated as 'def' in JsonOps (due to detected potential circular reference)")
  }

  // FIXME
//  swagger.securityDefinitions.foreach {
//    case (name, oauth2: OAuth2Definition) =>
//      println(s"Security defn: OAUTH2: name = $name, flow = ${oauth2.getFlow}, scopes = ${oauth2.getScopes}")
//    case (name, obj) =>
//      println(s"Security defn: ${obj.getClass.getName}, name = $name")
//  }

  // Get the errors first, and log to stderr.
  (swagger.routedControllersWithErrors()._2 ++ swagger.definitionsWithErrors()._2).foreach {
    case ParseError(msg, replacement, _) =>
      System.err.println(s"WARN - $msg - Replaced actual generated code with '$replacement'")
  }

  if (genServerCode) {
    val confDir = new File(outputDir, "conf")
    val appDir = new File(outputDir, "app")
    val controllersDir = new File(appDir, "controllers")
    val delegateTraitsDir = new File(controllersDir, "delegates")
    val modelsDir = new File(appDir, "models")

    Seq(confDir, controllersDir, delegateTraitsDir, modelsDir).map { dir =>
      (dir, dir.mkdirs())
    }.find(!_._2).foreach { case (dir, _) =>
      System.err.println(s"Failed to create directory '$dir'")
      System.exit(1)
    }

    writingToFile(new File(confDir, "routes")) {
      _.println(codegen.Routes.generate(swagger.routedControllers))
    }

    swagger.controllers.foreach { c =>
      writingToFile(new File(controllersDir, s"${c.name}.scala")) {
        _.println(codegen.Controller.generate(c))
      }
    }

    Delegates.extract(swagger.controllers).foreach { delegate =>
      writingToFile(new File(delegateTraitsDir, s"${delegate.className}.scala")) {
        _.println(codegen.ControllerDelegateTraits.generate(delegate))
      }
    }

    writingToFile(new File(modelsDir, "Models.scala")) {
      _.println(codegen.Models.generate("models", swagger.definitions()))
    }

    writingToFile(new File(modelsDir, "JsonOps.scala")) {
      _.println(codegen.JsonOps.generate("models", swagger.definitions(logCyclicDefinitionWarning)))
    }

    writingToFile(new File(modelsDir, "Enums.scala")) {
      // Disallowing unknown values in enum in server mode..
      _.println(codegen.Enums.generate("models", swagger.definitions(), false))
    }

  } else {
    val title = for {
      info <- Option(swagger.getInfo)
      title <- Option(info.getTitle)
    } yield title

    val clientPackageName = title.getOrElse("No Info Title Provided Package").replace(".", "").replace(" ", "_").toLowerCase
    val clientDir = new File(new File(outputDir, "clients"), clientPackageName)

    if (clientDir.isDirectory && replace) {
      FileUtils.deleteDirectory(clientDir)
    }

    Seq(clientDir).map { dir =>
      (dir, dir.mkdirs())
    }.find(!_._2).foreach { case (dir, _) if !dir.isDirectory =>
      System.err.println(s"Failed to create directory '$dir'")
      System.exit(1)
    }

    val clientModelPackageFqn = s"clients.$clientPackageName"

    writingToFile(new File(clientDir, "Models.scala")) {
      _.println(codegen.Models.generate(clientModelPackageFqn, swagger.definitions()))
    }

    writingToFile(new File(clientDir, "JsonOps.scala")) {
      _.println(codegen.JsonOps.generate(clientModelPackageFqn, swagger.definitions(logCyclicDefinitionWarning)))
    }

    writingToFile(new File(clientDir, "Client.scala")) {
      _.println(codegen.Client.generate(clientModelPackageFqn, swagger.controllers(), generatePlay23Code))
    }

    writingToFile(new File(clientDir, "Enums.scala")) {
      // Allow unknown values in enum in client mode..
      _.println(codegen.Enums.generate(clientModelPackageFqn, swagger.definitions(), true))
    }
  }

  private def writingToFile(file: File)(fn: PrintWriter => Unit): Unit = {
    val writer = new PrintWriter(file)
    try {
      fn(writer)
    } finally {
      writer.close()
    }
  }
}

